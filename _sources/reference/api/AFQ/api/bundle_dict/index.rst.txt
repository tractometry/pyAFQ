:py:mod:`AFQ.api.bundle_dict`
=============================

.. py:module:: AFQ.api.bundle_dict


Module Contents
---------------

Classes
~~~~~~~

.. autoapisummary::

   AFQ.api.bundle_dict.BundleDict



Functions
~~~~~~~~~

.. autoapisummary::

   AFQ.api.bundle_dict.default18_bd
   AFQ.api.bundle_dict.baby_bd
   AFQ.api.bundle_dict.callosal_bd
   AFQ.api.bundle_dict.reco_bd
   AFQ.api.bundle_dict.cerebellar_bd



.. py:function:: default18_bd()


.. py:function:: baby_bd()


.. py:function:: callosal_bd()


.. py:function:: reco_bd(n_bundles)

   
   n_bundles: int
       Selects between 16 or 80 bundle atlas
















   ..
       !! processed by numpydoc !!

.. py:function:: cerebellar_bd()


.. py:class:: BundleDict(bundle_info, resample_to=None, resample_subject_to=False, keep_in_memory=False)


   Bases: :py:obj:`collections.abc.MutableMapping`

   
   Create a bundle dictionary, needed for the segmentation.


   :Parameters:

       **bundle_info** : dict,
           A dictionary defining
           custom bundles. See `Defining Custom Bundle Dictionaries`
           in the `usage` section of pyAFQ's documentation for details.

       **resample_to** : Nifti1Image or bool, optional
           If there are bundles in bundle_info with the 'space' attribute
           set to 'template', or with no 'space' attribute,
           their images (all ROIs and probability maps)
           will be resampled to the affine and shape of this image.
           If None, the MNI template will be used.
           If False, no resampling will be done.
           Default: None

       **resample_subject_to** : Nifti1Image or bool, optional
           If there are bundles in bundle_info with the 'space' attribute
           set to 'subject', their images (all ROIs and probability maps)
           will be resampled to the affine and shape of this image.
           If None, resamples to DWI. Be careful if you use this,
           that this is the correct choice.
           If False, no resampling will be done.
           Default: False

       **keep_in_memory** : bool, optional
           Whether, once loaded, all ROIs and probability maps will stay
           loaded in memory within this object. By default, ROIs are loaded
           into memory on demand and no references to ROIs are kept, other
           than their paths. The default 18 bundles use ~6GB when all loaded.
           Default: False











   .. rubric:: Examples

   # import OR ROIs and create a custom bundle dict
   # from them
   import AFQ.data.fetch as afd
   or_rois = afd.read_or_templates()

   bundles = BundleDict({
       "L_OR": {
           "include": [
               or_rois["left_OR_1"],  # these can be paths to Nifti files
               or_rois["left_OR_2"]],  # or they can Nifti images
           "exclude": [
               or_rois["left_OP_MNI"],
               or_rois["left_TP_MNI"],
               or_rois["left_pos_thal_MNI"]],
           "start": or_rois['left_thal_MNI'],
           "end": or_rois['left_V1_MNI'],
           "cross_midline": False,
       },
       "R_OR": {
           "include": [
               or_rois["right_OR_1"],
               or_rois["right_OR_2"]],
           "exclude": [
               or_rois["right_OP_MNI"],
               or_rois["right_TP_MNI"],
               or_rois["right_pos_thal_MNI"]],
           "start": or_rois['right_thal_MNI'],
           "end": or_rois['right_V1_MNI'],
           "cross_midline": False
       }
   })



   ..
       !! processed by numpydoc !!
   .. py:method:: __print__()


   .. py:method:: update_max_includes(new_max)


   .. py:method:: _use_bids_info(roi_or_sl, bids_layout, bids_path, subject, session)


   .. py:method:: _cond_load(roi_or_sl, resample_to)

      
      Load ROI or streamline if not already loaded
















      ..
          !! processed by numpydoc !!

   .. py:method:: get_b_info(b_name)


   .. py:method:: __getitem__(key)


   .. py:method:: __setitem__(key, item)


   .. py:method:: __len__()


   .. py:method:: __delitem__(key)


   .. py:method:: __iter__()


   .. py:method:: copy()

      
      Generates a copy of this BundleDict where the internal dictionary
      is a copy of this BundleDict's internal dictionary.
      Useful if you want to add or remove bundles from a copy
      of a BundleDict.



      :Returns:

          **bundle_dict** : BundleDict
              Euclidean norms of vectors.













      ..
          !! processed by numpydoc !!

   .. py:method:: apply_to_rois(b_name, *args, **kwargs)

      
      See: AFQ.api.bundle_dict.apply_to_roi_dict


      :Parameters:

          **b_name** : name
              bundle name of bundle whose ROIs will be transformed.














      ..
          !! processed by numpydoc !!

   .. py:method:: _cond_load_bundle(b_name, dry_run=False)

      
      Given a bundle name, resample all ROIs and prob maps
      into either template or subject space for that bundle,
      depending on its "space" attribute.


      :Parameters:

          **b_name** : str
              Name of the bundle to be resampled.














      ..
          !! processed by numpydoc !!

   .. py:method:: is_bundle_in_template(bundle_name)


   .. py:method:: _roi_transform_helper(roi_or_sl, mapping, new_affine, bundle_name)


   .. py:method:: transform_rois(bundle_name, mapping, new_affine, base_fname=None, to_space='subject', apply_to_recobundles=False)

      
      Get the bundle definition with transformed ROIs
      for a given bundle into a
      given subject space using a given mapping.
      Will only run on bundles which are in template
      space, otherwise will just return the bundle
      definition without transformation.


      :Parameters:

          **bundle_name** : str
              Name of the bundle to be transformed.

          **mapping** : DiffeomorphicMap object
              A mapping between DWI space and a template.

          **new_affine** : array
              Affine of space transformed into.

          **base_fname** : str, optional
              Base file path to construct file path from. Additional BIDS
              descriptors will be added to this file path. If None,
              no file paths returned.

          **to_space** : str, optional
              Name for space for exported ROIs. Only used if base_fname
              is not None.
              Default: "subject"

          **apply_to_recobundles** : bool, optional
              Whether to apply the transformation to recobundles
              TRKs as well.
              Default: False

      :Returns:

          If base_fname is None, a dictionary where keys are
              ..

          the roi type and values are the transformed ROIs.
              ..

          Otherwise, a list of file names and a list of transformed ROIs
              ..

          are returned.
              ..













      ..
          !! processed by numpydoc !!

   .. py:method:: __add__(other)



