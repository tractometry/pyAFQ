:py:mod:`AFQ.recognition.other_bundles`
=======================================

.. py:module:: AFQ.recognition.other_bundles


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   AFQ.recognition.other_bundles.clean_by_other_density_map
   AFQ.recognition.other_bundles.clean_relative_to_other_core



Attributes
~~~~~~~~~~

.. autoapisummary::

   AFQ.recognition.other_bundles.logger


.. py:data:: logger

   

.. py:function:: clean_by_other_density_map(this_bundle_sls, other_bundle_sls, node_thresh, img)

   
   Cleans a set of streamlines by removing those with significant overlap with 
   another set of streamlines.


   :Parameters:

       **this_bundle_sls** : array-like
           A list or array of streamlines to be cleaned.

       **other_bundle_sls** : array-like
           A reference list or array of streamlines to determine overlapping regions.

       **node_thresh** : int
           The maximum number of nodes allowed to overlap between `this_bundle_sls`
           and `other_bundle_sls`. Streamlines with overlaps beyond this threshold 
           are removed.

       **img** : nibabel.Nifti1Image or ndarray
           A reference 3D image that defines the spatial dimensions for the density 
           map.

   :Returns:

       **cleaned_idx** : ndarray of bool
           An array of boolean values indicating which streamlines from 
           `this_bundle_sls` pass the overlap threshold (True for streamlines to 
           keep, False for streamlines to discard).








   .. rubric:: Notes

   This function computes a density map from `other_bundle_sls` to represent 
   the spatial occupancy of the streamlines. It then calculates the probability
   of each streamline in `this_bundle_sls` overlapping with this map. 
   Streamlines that overlap in more than `node_thresh` nodes are flagged for 
   removal.


   .. rubric:: Examples

   >>> clean_idx = clean_by_other_density_map(bundle1, bundle2, 5, img)
   >>> cleaned_bundle = [s for i, s in enumerate(bundle1) if clean_idx[i]]



   ..
       !! processed by numpydoc !!

.. py:function:: clean_relative_to_other_core(core, this_fgarray, other_fgarray, affine)

   
   Removes streamlines from a set that lie on the opposite side of a specified 
   core axis compared to another set of streamlines.


   :Parameters:

       **core** : {'anterior', 'posterior', 'superior', 'inferior', 'right', 'left'}
           The anatomical axis used to define the core direction. This determines 
           the side of the core from which streamlines in `this_fgarray` are 
           retained.

       **this_fgarray** : ndarray
           An array of streamlines to be cleaned.

       **other_fgarray** : ndarray
           An array of reference streamlines to define the core.

       **affine** : ndarray
           The affine transformation matrix.

   :Returns:

       **cleaned_idx_core** : ndarray of bool
           An array of boolean values indicating which streamlines in `this_fgarray`
           lie on the correct side of the core (True for streamlines to keep, False 
           for streamlines to discard).








   .. rubric:: Notes

   This function first calculates the median streamline of `other_fgarray`, 
   which acts as the core line. It then determines whether each streamline in 
   `this_fgarray` is on the specified side of this core, based on the specified
   anatomical axis (`core`). Streamlines on the opposite side are flagged for 
   removal.


   .. rubric:: Examples

   >>> cleaned_core_idx = clean_relative_to_other_core('anterior', 
   ...                                                 streamlines1, 
   ...                                                 streamlines2, 
   ...                                                 np.eye(4))
   >>> cleaned_streamlines = [s for i, s in enumerate(streamlines1) 
   ...                        if cleaned_core_idx[i]]



   ..
       !! processed by numpydoc !!

